https://juejin.cn/post/6844903965629349895#heading-11

MongoDB应用场景：
1）表结构不明确且数据不断变大
MongoDB是非结构化文档数据库，扩展字段很容易且不会影响原有数据。内容管理或者博客平台等，例如圈子系统，存储用户评论之类的。
2）更高的写入负载
MongoDB侧重高数据写入的性能，而非事务安全，适合业务系统中有大量“低价值”数据的场景。本身存的就是json格式数据。例如做日志系统。
3）数据量很大或者将来会变得很大
Mysql单表数据量达到5-10G时会出现明细的性能降级，需要做数据的水平和垂直拆分、库的拆分完成扩展，MongoDB内建了sharding、很多数据分片的特性，容易水平扩展，比较好的适应大数据量增长的需求。
4）高可用性
自带高可用，自动主从切换（副本集）

不适用的场景
1）MongoDB不支持事务操作，需要用到事务的应用建议不用MongoDB。
2）MongoDB目前不支持join操作，需要复杂查询的应用也不建议使用MongoDB。

mongo是一个c++编写的、面向文档存储的非关系型数据库

mongo底层数据结构是什么？
https://blog.csdn.net/m0_38110132/article/details/77716792
mongo中的document对应着collection的一行数据，document的底层实现是基于bson实现的
BSON是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，如Date和BinData类型。
BSON可以做为网络数据交换的一种存储形式，这个有点类似于Google的Protocol Buffer，但是BSON是一种schema-less的存储形式，它的优点是灵活性高，但它的缺点是空间利用率不是很理想，
bson的优势
（1）更快的遍历速度
对JSON格式来说，太大的JSON结构会导致数据遍历非常慢。在JSON中，要跳过一个文档进行数据读取，需要对此文档进行扫描才行，需要进行麻烦的数据结构匹配，比如括号的匹配，而BSON对JSON的一大改进就是，它会将JSON的每一个元素的长度存在元素的头部，这样你只需要读取到元素长度就能直接seek到指定的点上进行读取了。
（2）操作更简易
对JSON来说，数据存储是无类型的，比如你要修改基本一个值，从9到10，由于从一个字符变成了两个，所以可能其后面的所有内容都需要往后移一位才可以。而使用BSON，你可以指定这个列为数字列，那么无论数字从9长到10还是100，我们都只是在存储数字的那一位上进行修改，不会导致数据总长变大。当然，在MongoDB中，如果数字从整形增大到长整型，还是会导致数据总长变大的。
（3）增加了额外的数据类型
JSON是一个很方便的数据交换格式，但是其类型比较有限。BSON在其基础上增加了“byte array”数据类型。这使得二进制的存储不再需要先base64转换后再存成JSON。大大减少了计算开销和数据大小。
bson的劣势
BSON相对JSON来说也并没有空间上的优势，比如对{“field”:7}，在JSON的存储上7只使用了一个字节，而如果用BSON，那就是至少4个字节（32位）

mongo索引为什么使用b树？
https://www.zhihu.com/question/28774706
mongo中的索引
mongo中的索引结构采用的是b树
mongo是一个nosql数据库，单条查询比较多，而b树和b+树的区别是b树非叶子节点都有数据，b+树的数据只存储在叶子节点，所以单次查询的话，b树磁盘io次数少，效率更高

遇到的实际问题，mongo建索引造成表暂时不可用。可以使用background属性进行设置后台索引创建
在密集(快达到数据库最大容量）Collection创建索引：在默认情况下，在密集的Collection（快达到数据库最大容量）时创建索引，会阻止其他操作。在给密集的Collection（快达到数据库最大容量）创建索引时，
索引构建完成之前，保存Collection的数据库不可用于读取或写入操作。 任何需要对所有数据库（例如listDatabases）进行读或写锁定的操作都将等待后台进程的索引构建完成。

mongo索引的知识点是什么？
https://juejin.cn/post/6844903905441103880
单字段索引
复合索引
mongo支持一种全文索引，支持在Collection中搜索字符串内容，对字符串与字符串数组创建全文可搜索的索引 。
ttl索引是特殊的单字段索引，并且字段类型必须是date类型或者包含有date类型的数组，MongoDB可以使用它在一定时间后或在特定时钟时间自动从集合中删除文档。
唯一索引可确保索引字段不存储重复值; 即强制索引字段的唯一性。

当数据量大到单机无法容纳时，mongo怎么实现水平扩展和高可用？
http://kaelzhang81.github.io/2016/12/18/mongodb%E9%AB%98%E5%8F%AF%E7%94%A8%E6%A6%82%E5%BF%B5%E7%AF%87/
官方建议使用shard来分散读写请求。提高读取性能应该使用分片和索引，副本集的存在是为了数据冗余和备份
mongo水平扩展通过shard分片来支持水平扩展并且拓展读性能，当一条数据插入时，shard会将这条数据放进某个分片中，同时报了保证高可用，所以每个分片通常也是一个复制集。

高可用是通过副本集来实现，副本集(Replica Set)可以认为是具有自动故障恢复能力的一主多从架构，主节点记录在其上的所有操作oplog(operation log)，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致。
主节点用于处理客户端读写请求，从节点用于保存主服务器的数据副本，仲裁节点用于保障选举出主节点。
主从节点间通过心跳机制来判断主节点是否可用，并用基于raft算法实现的bully算法实现选主流程
MongoDB使用两种形式的数据同步：初始化同步新节点同步完整的数据集，以及整个集群节点同步后续数据更改。

bully算法 VS raft算法
1、raft使用强领导模型。领导负责管理从主节点到其他节点的复制和数据流。而在MongoDB副本集中，从节点遵循上游节点的操作日志（oplog），上游节点可以是主节点，也可以是具有较新oplog的从节点。
2、raft只有三个节点状态要考虑：领导（主），随从（从）以及候选者（选主）。 MongoDB有其他节点状态要考虑，包括更多的潜在错误状态，如RECOVERING节点、SHUNNED节点及延迟节点等。
3、在raft中，每个选举期间每个节点只能为候选节点投一次票。 MongoDB可将节点投票存为副本集配置中，因此节点即可以不投票也可以多次投票。
4、raft使用联合共识方法，允许集群在配置更改期间继续操作。 MongoDB在选举过程中，由于副本集没有主节点，所以不能写入数据。

mongo副本集中的节点角色有隐藏节点、延迟备份节点、仲裁节点，优先级0级节点，mongo可以定义某些节点的优先级，使其在选主的时候不会成为主节点

https://juejin.cn/post/6844903919659778055
mongo write_concern和read_concern模式是什么？
write concern
Write concern描述了在操作返回成功之前必须确认写操作的数据承载成员（即主节点成员和从节点成员，但不是仲裁者）的数量。成员只能在收到并成功应用写入后才能确认写入操作。
read_concern
primary：默认模式，读操作只在活跃节点，如果活跃节点不可用，报错或者抛出异常。
primaryPreferred：首选活跃节点，大多情况下读操作在活跃节点，如果活跃节点不可用，如故障转移，读操作在备份节点。
secondary：读操作只在备份节点， 如果备份节点不可用，报错或者抛出异常。
secondaryPreferred：首选备份节点，大多情况下读操作在备份节点，特殊情况（如单节点架构）读操作则会在活跃节点。
nearest：最邻近节点，读操作在最邻近的成员，可能是活跃节点，也可能是备份节点。
需要注意的是除了primary模式外，其他模式都可能会读到脏数据。

为什么nosql很快？
https://my.oschina.net/xsh1208/blog/3005359
mongo修改的是内存的文档，接着就直接返回了。这过程的详细信息如下：
Mongo使用了内存映射技术 － 写入数据时候只要在内存里完成就可以返回给应用程序，而保存到硬体的操作则在后台异步完成。
内存映射简单来讲内存映射文件是操作系统通过mmap内存映射将磁盘空间地址映射到一个虚拟内存的区域，同时把数据load进内存，当进程访问某个数据时，如果不在内存，触发
page fault加载数据进虚拟内存和物理内存，如果内存满了，触发有些数据写回磁盘

mongo中的journal日志和oplog是什么？
journal日志和oplog是两个维度上的概念，journal日志类似于mysql redolog，是存储引擎层的概念
开启 journal 后，每次写入会记录一条操作日志（通过journal可以重新构造出写入的数据）。 这样即使出现宕机，启动时 Wiredtiger 会先将数据恢复到最近的一次checkpoint的点，然后重放后续的 journal 操作日志来恢复数据。
oplog是mongo副本集的一个概念，通过 oplog 来实现复制集节点间数据同步

mongo中的事务是怎样理解的?
https://www.zybuluo.com/JunQiu/note/1300258
MongoDB 在单文档操作中具有原子性，在多文档操作中就不再具有此特性，通常需要借助事务来实现 ACID 特性。
对于mongo分片副本集模式，当写入一条数据时，需要做以下操作：
1，向集合中插入数据 2，更新索引 3，记录oplog 
mongo会将上述3个操作放入wiredtiger 的事务里，确保「原子性」
原子性：
所以mongo中的事务保证的是单文档事务的原子性，不能保证多文档事务的原子性，但mongo4.0介绍说能保证多文档事务，但在大多数情况下，多文档事务比单文档事务具有更多的花销，推荐使用单文档事务+建模取代多文档事务
一致性：
MongoDB支持强一致性或最终一致性（弱一致性），能过参数write_concern来保证
隔离性：
mongo能保证实现rc级别
持久性：
传统数据库这种方式叫做“WAL” Write-Ahead Logging（预写日志系统），而MongoDB叫做“journal”

mongo的适用场景和非适用场景是什么？
https://my.oschina.net/xsh1208/blog/3005359
1、非结构化数据存储
2、数据缓存：由于性能很高，MongoDB 也适合作为信息基础设施的缓存层
游戏场景：使用Mongodb存储游戏用户信息，用户的装备，机分等直接以内嵌文档的形式存储，方便查询和更新。
物流场景：使用Mongodb存储订单信息，订单状态在运送过程中会不断更新，以Mongodb内嵌数组的形式存储，一次查找就能把订单所有的变更读取出来。
社交场景：使用Mongodb存储用户信息，以及用户发表的朋友圈信息，通过地理位置索引实现附近的人，地点等功能。
移动端Apps：O2O送快递骑手、快递商家的信息（包含位置信息）

不适用场景：
1）高度事务性系统
3）需要复杂 SQL 查询的问题。

更新操作会立刻fsync到磁盘?
不会,磁盘写操作默认是延迟执行的.写操作可能在两三秒(默认在60秒内)后到达磁盘，通过 syncPeriodSecs 启动参数，可以进行配置.
例如,如果一秒内数据库收到一千个对一个对象递增的操作,仅刷新磁盘一次.

索引类型有哪些？
单字段索引(Single Field Indexes)
复合索引(Compound Indexes)
多键索引(Multikey Indexes)
全文索引(text Indexes)
Hash 索引(Hash Indexes)
通配符索引(Wildcard Index)
2dsphere索引(2dsphere Indexes)

数据在什么时候才会扩展到多个分片(Shard)里?
MongoDB 分片是基于区域(range)的。所以一个集合(collection)中的所有的对象都被存放到一个块(chunk)中,默认块的大小是 64Mb。
当数据容量超过64 Mb，才有可能实施一个迁移，只有当存在不止一个块的时候，才会有多个分片获取数据的选项。

