# 背景

相关技术栈: Java JVM

### 线程安全性
线程安全的代码，核心在于对状态访问操作进行管理，特别是共享和可变状态的访问。对象的状态是指存储在实例域或静态域中的数据。一个类如果没有任何域，也没有任何对其它类中域的引用，计算过程中的临时状态存储在线程栈上的局部变量中，并且只能由正在执行的线程访问，则这个对象是线程安全的。

在实际情况中，应尽可能使用线程安全对象管理类的状态。

以关键字synchronized修饰的方法是一种横跨整个方法体的同步代码块，其中该同步代码块的锁是方法调用所在的对象，静态的synchronized方法以Class对象作为锁。每个Java对象都可以用作一个实现同步的锁，也就是所说的内置锁。
Java内置锁是互斥的，也是可重入的。可重入是指如果某个线程视图获得一个由它自己持有的锁，不会被阻塞，也就说获取锁的粒度是线程。之所以每个对象都有一个内置锁，是为了免去显式创建锁的过程。

`if(!vector.contains(element) vector.add(element)`

虽然synchronized方法可以确保单个操作的原子性，但假如像上述代码把多个操作合并为一个复合操作，仍需要额外的加锁机制。
### 对象的共享
同步不仅意味着原子性，同时还有一个很重要的方面，内存可见性。线程安全不仅希望防止某个线程在使用对象状态而另一个线程同时在修改状态，而且希望确保当一个线程修改了对象状态后，其它线程能看到发生的状态变化。
为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
PS：Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，对于volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。当读取到一个非volatile类型的long变量时，如果对该变量的读操作和写操作在不同的线程中执行，可能会读取到某个值的高32位和另一个值的低32位。
为什么访问某个共享且可变的变量要求在同一个锁上同步？为了确保某个线程写入该变量的值对其它线程来说都是可见的，否则一个线程在未持有正确锁的情况下读取某个变量，读到的可能是一个失效值。
加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

volatile变量
当把变量声明为Volatile类型后，编译和运行时会禁止指令重排序。volatile变量不会被缓存在寄存器或者其它处理器不可见的地方，因此读取volatile变量总会返回最新写入的值。
volatile变量不能保证原子性，只能保证可见性，典型的应用场景用作状态标记判断是否退出循环。
`volatile boolean asleep  while(!asleep) exec();`
只有当满足以下所有条件，才能使用volatile变量：
1、对变量的写入操作不依赖变量当前值
2、该变量不与其它变量一起纳入不变性条件
3、访问变量时不需要加锁

ThreadLocal类
ThreadLocal对象通常用于防止对可变的单实例对象或全局变量进行共享，这个类能使线程中的某个值与保存值的对象关联起来，ThreadLocal提供get或set等访问接口或方法，这些方法为每个使用该变量的线程存有一份独立的副本，因此get总能返回由当前执行线程在调用set时设置的最新值。所以，可以理解ThreadLocal<T>视为Map<Thread, t>对象，
不过具体实现并不是这样，这些特定于线程的值保存在Thread对象中，当线程终止后，对象会作为垃圾回收。
个人理解，TreadLocal对象适合存储那种稀缺全局资源，例如数据库连接等。

### 显式锁
Java5.0增加ReentrantLock，不是为了替代内置锁，而是当内置锁不适用时，作为一种可选择的高级功能。
与内置锁机制不同，Lock提供一种无条件的、可轮询的、定时的及可中断的锁获取操作，所有加锁和解锁都是显式的。ReentrantLock实现了Lock接口，提供与synchronized相同的互斥性和内存可见性。
内置锁的局限性，无法中断一个正在等待获取锁的线程。Lock接口的标准使用形式，在finally块中释放锁。
可定时的与可轮询的锁获取模式是由tryLock方法实现，可定时的与可轮询的锁提供另一种选择，避免死锁的发生。

如果线程不能获取到所有需要的锁，那么可使用可定时的活可轮询的锁获取方式，重新获得控制权，它会释放已经获得的锁，然后重新尝试获取所有锁。
在实现具有时间限制的操作中，定时锁同样非常有用。当在带有时间限制的操作中调用了一个阻塞方法时，它会根据剩余时间提供一个期限，如果操作不能在给定的时间内给出结果，会使程序提前结束。
正如定时的锁获取操作能在带有时间限制的操作中使用独占锁，可中断的锁获取操作同样能在可取消的操作中使用加锁。lockInterruptibly方法能在获得锁的同时保持对中断的响应。

ReentrantLock默认是非公平锁。公平锁是指按照线程发出请求的顺序来获取锁，而非公平锁是指当线程发出请求锁的时候，如果在发出请求的同时该锁的状态变为可用，那么这个线程将跳过队列中所有的等待线程并获得这个锁。
在大多数情况下，非公平锁的性能要高于公平锁的性能，在激烈竞争的情况下，吞吐量会提高。在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟，有可能存在当唤醒一个等待的线程的时候，可以请求、使用、执行和释放线程。
当持有锁的时间相对较长，或者请求锁的平均时间间隔较长，应该使用公平锁。

仅当内置锁不能满足需求时，才考虑使用ReentrantLock。在一些内置锁无法满足需求的情况下，当需要一些高级功能时，应该使用ReentrantLock，这些功能包括：可定时的、可轮询的与可中断的锁获取操作，公平队列，以及非块结构的锁。

ReentrantLock实现了标准的互斥锁，每次最多只有一个线程持有ReentrantLock。

读-写锁
ReadWriteLock
`public interface ReadWriteLock { Lock readLock(); Lock writeLock();}`

读写锁是一种性能优化措施，实际情况下，对于在多处理器系统上被频繁读取的数据结构，读-写锁能提高性能。其它情况下，读-写锁的性能比独占锁的性能略差一些，因为复杂性更高。

ReentrantReadWriteLock为这两种锁提供了可重入的加锁语义，构造时也可以选择是否公平，
如果这个锁由读线程持有，而另一个线程请求写入锁，那其它读线程都不能获得读取锁，直到写线程使用完并且释放了写入锁。写线程降级为读线程可以，读线程升级为写线程不行，这样做会导致死锁。

当锁的持有时间较长且大部分操作都不会修改被守护的资源时，读-写锁能提高并发性。

与内置锁相比，显式的Lock提供了一些扩展功能，在处理锁的不可用性方面有着更高的灵活性。ReentrantLock不能完全替代synchronized，只有在synchronized无法满足需求时，才应该使用它。

## 博客总结
如果一个线程调用了一个对象的同步方法，例如synchronized xxx()这种形式，那么这个线程不仅持有该类对象的锁，同时持有该父类对象的锁，因此其它线程不能访问父类中的其它同步方法，调用线程会进入阻塞状态。
<https://blog.csdn.net/u014745069/article/details/80753363>

## 线程死锁
public class DeadlockSample {
	
	//必须有两个可以被加锁的对象才能产生死锁，只有一个不会产生死锁问题
    private final Object obj1 = new Object();
    private final Object obj2 = new Object();

    
    //先synchronized  obj1，再synchronized  obj2
    private void calLock_Obj1_First() {
        synchronized (obj1) {
            Thread.sleep(5);
            synchronized (obj2) {
                sleep();
            }
        }
    }
    
    //先synchronized  obj2，再synchronized  obj1
    private void calLock_Obj2_First() {
        synchronized (obj2) {
            Thread.sleep(5);
            synchronized (obj1) {
                sleep();
            }
        }
    }
}

## 参考
《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版)》
