一、序列化的含义、意义及使用场景 

序列化：将对象写入到IO流中
反序列化：从IO流中恢复对象
意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。
使用场景：所有可在网络上传输的对象都必须是可序列化的，比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。

二、序列化实现方式
如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现Serializable接口或者Externalizable接口之一。

1、Serializable
Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。

反序列化并不会调用构造方法。反序列的对象是由JVM自己生成的对象，不通过构造方法生成。

如果一个可序列化的类的成员不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。

同一对象序列化多次的机制
同一对象序列化多次，会将这个对象序列化多次吗？答案是否定的。
反序列化生成的对象是同一个

Java序列化算法
1，所有保存到磁盘的对象都有一个序列化编码号
2，当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。
3，如果此对象已经序列化过，则直接输出编号即可。

java序列化算法潜在的问题
由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。
如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。

有些时候，我们有这样的需求，某些属性不需要序列化。使用transient关键字选择不需要序列化的字段。

使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。
对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。

一个静态变量不管是否被transient修饰，均不能被序列化。 因为static修饰的属性是属于类，而非对象。
当一个父类实现序列化，子类就会自动实现序列化，不需要显式实现Serializable接口

Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。

序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量

什么情况下需要修改serialVersionUID呢？分三种情况。
如果只是修改了方法，反序列化不容影响，则无需修改版本号；
如果只是修改了静态变量，瞬态变量（transient修饰的变量），反序列化不受影响，无需修改版本号；
如果修改了非瞬态变量，则可能导致反序列化失败。如果新类中实例变量的类型与序列化时类的类型不一致，则会反序列化失败，这时候需要更改serialVersionUID。如果只是新增了实例变量，则反序列化回来新增的是默认值；如果减少了实例变量，反序列化时会忽略掉减少的实例变量。

Json序列化
在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。

4.、序列化的存储规则
(1) 同一个对象两次(开始写入文件到最终关闭流的这个过程算一次），如果不关闭流写入文件两次，则第二次写入对象时文件只增加5字节。
(2) Java序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用，
上面增加的5字节的存储空间就是新增 引用和一些控制信息的空间。反序列化时，恢复引用关系，该存储规则极大的节省了存储空间。

10、序列化可以作为深clone的一种实现方式
在 Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。
实现 Serializable 接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。

https://juejin.cn/post/6844904070101090311
https://juejin.cn/post/6844903848167866375

常见的序列化技术
1、java 序列化
优点：java语言本省提供，使用比较方面和简单
缺点：不支持跨语言处理、性能相对不是很好，序列化以后产生的数据相对较大
2、XML序列化
XML序列化的好处在于可读性好，方便阅读和调试。但是序列化以后的 字节码文件比较大，而且效率不高，适应于对性能不高，而且QPS较低的企业级内部系统之间的数据交换的场景，同时XML又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如我们熟知的WebService,就是采用XML格式对数据进行序列化的
3、JSON序列化
JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，相对于XML来说，JON的字节流较小，而且可读性也非常好。现在JSON数据格式的其他运用最普遍的。
4、Hessian 序列化框架子
Hessian是一个支持跨语言传输的二进制序列化协议，相对于Java默认的序列化机制来说，Hessian具有更好的性能和易用性，而且支持多重不同的语言，实际上Dubbo采用的就是Hessian序列化来实现，只不过Dubbo对Hessian进行重构，性能更高。
5、Protobuf 序列化框架
Protobuf是Google的一种数据交换格式，它独立于语言、独立于平台。
Google 提供了多种语言来实现，比如 Java、C、Go、Python，每一种实现都包含了相应语言的编译器和库文件Protobuf 使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要求高的 RPC 调用。 另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应用在对象的持久化场景中但是但是要使用 Protobuf 会相对来说麻烦些，因为他有自己的语法，有自己的编译器。

序列化技术选型
① 对性能要求不高的场景，可以采用基于 XML 的 SOAP 协议
② 对性能和间接性有比较高要求的场景，那么Hessian、Protobuf、Thrift、Avro 都可以
③ 基于前后端分离，或者独立的对外的 api 服务，选用 JSON 是比较好的，对于调试、可读性都很不错
④ Avro 设计理念偏于动态类型语言，那么这类的场景使用 Avro 是可以的