一、序列化的含义、意义及使用场景 

序列化：将对象写入到IO流中
反序列化：从IO流中恢复对象
意义：序列化机制允许将实现序列化的Java对象转换位字节序列，这些字节序列可以保存在磁盘上，或通过网络传输，以达到以后恢复成原来的对象。序列化机制使得对象可以脱离程序的运行而独立存在。
使用场景：所有可在网络上传输的对象都必须是可序列化的，比如RMI（remote method invoke,即远程方法调用），传入的参数或返回的对象都是可序列化的，否则会出错；所有需要保存到磁盘的java对象都必须是可序列化的。通常建议：程序创建的每个JavaBean类都实现Serializeable接口。

二、序列化实现方式
如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现Serializable接口或者Externalizable接口之一。

1、Serializable
Serializable接口是一个标记接口，不用实现任何方法。一旦实现了此接口，该类的对象就是可序列化的。

反序列化并不会调用构造方法。反序列的对象是由JVM自己生成的对象，不通过构造方法生成。

如果一个可序列化的类的成员不是基本类型，也不是String类型，那这个引用类型也必须是可序列化的；否则，会导致此类不能序列化。

同一对象序列化多次的机制
同一对象序列化多次，会将这个对象序列化多次吗？答案是否定的。
反序列化生成的对象是同一个

Java序列化算法
1，所有保存到磁盘的对象都有一个序列化编码号
2，当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。
3，如果此对象已经序列化过，则直接输出编号即可。

java序列化算法潜在的问题
由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。
如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。

有些时候，我们有这样的需求，某些属性不需要序列化。使用transient关键字选择不需要序列化的字段。

使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。
对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。

