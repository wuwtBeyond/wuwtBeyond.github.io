
redis 数据结构
string list set zset hash

redis是有C语言实现的

string 底层是simple dynamic string，动态字符串，是redis自己实现的数据结构，优点是无需担心内存溢出，常数时间能获取长度，扩容会预分配内存

hash 扩容，会生成一个新的hash表ht[1]，原hash表 ht[0]  渐进式hash+辅助rehash
渐进式hash,每一次操作会将ht[0]的数据迁移到ht[1]中，ht[0]不再新增数据，也就是ht[0]处于不断缩小的状态
辅助rehash，当服务器负载不高的时候，会自动作hash迁移
优点：采取分治的思想实现平滑迁移 缺点：内存使用量变大

只有在没有执行redis持久化的时候，才可以执行扩缩容

持久化
RDB方式比较粗粒度，发生故障时，两次持久化之间的数据会丢失
AOF方式会写磁盘，如果io慢，会阻塞主进程


redis6.0引入多线程，指的是网络io处理方面引入多线程，read/write系统调用相对于命令的执行占用了大量的CPU时间，执行命令仍然是单线程，看过初略对比，多线程读写性能是单线程的两倍

redis事务
客户端执行multi命令，客户端状态切换，从非事务状态切换到事务状态，不支持嵌套事务
redis事务不支持回滚
Redis事务执行过程中，如果一个命令执行出错，那么就返回错误，然后还是会接着继续执行下面的命令。

命令入队
如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。
与此相反，如果客户端发送的命令是 EXEC、DISCARD、WATCH、MULTI 四个命令以外的其他命令，那么服务器并不立即执行这个命令。
首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性打开 REDIS_MULTI 标识，并且返回错误信息给客户端。
如果正确将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复。

客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑。

如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。
否则客户端处于事务状态（flags 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；

redis作缓存

什么是缓存雪崩？
缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。
例如，
1，Redis挂掉了，请求全部走数据库。
2，对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。

如何预防缓存雪崩？
1，缓存数据设置的过期时间是相同
解决在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。
2，Redis挂掉
事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。
事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

什么是缓存穿透？
查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。
请求的数据在缓存大量不命中，导致请求走数据库。

如何预防缓存穿透？
1，接口参数校验，由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！
2，当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间。
从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值具体取啥问产品，或者看具体的场景，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。

Redis还有一个高级用法**布隆过滤器（Bloom Filter）**这个也能很好的防止缓存穿透的发生，
他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。

什么是缓存击穿？
至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，
而缓存击穿不同的是缓存击穿是指一个Key非常热点，在不停的扛着大并发，
大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

如何保证缓存和数据库的一致性？
四种缓存模式：
cache aside模式 cache和数据库分开
读操作，缓存没有时，读数据库然后写进缓存；写操作，先写数据库，然后使缓存失效
什么时候使用：
1，当Cache不提供原生的Read-Through和Write-Through操作的时候
2，资源的需求是不可预测的时候。Cache-Aside模式令应用可以根据需求来加载数据。对于应用需求什么数据，不需要提前做出假设。

read through模式 缓存和数据库是一个整体

write through模式 缓存和数据库是一个整体

write back模式 读写都在缓存，异步批量更新数据库




