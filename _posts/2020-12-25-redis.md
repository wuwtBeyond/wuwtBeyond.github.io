
redis 数据结构
string list set zset hash

redis是有C语言实现的

string 底层是simple dynamic string，动态字符串，是redis自己实现的数据结构，优点是无需担心内存溢出，常数时间能获取长度，扩容会预分配内存

hash 扩容，会生成一个新的hash表ht[1]，原hash表 ht[0]  渐进式hash+辅助rehash
渐进式hash,每一次操作会将ht[0]的数据迁移到ht[1]中，ht[0]不再新增数据，也就是ht[0]处于不断缩小的状态
辅助rehash，当服务器负载不高的时候，会自动作hash迁移
优点：采取分治的思想实现平滑迁移 缺点：内存使用量变大

只有在没有执行redis持久化的时候，才可以执行扩缩容

持久化
RDB方式比较粗粒度，发生故障时，两次持久化之间的数据会丢失
AOF方式会写磁盘，如果io慢，会阻塞主进程


redis6.0引入多线程，指的是网络io处理方面引入多线程，read/write系统调用相对于命令的执行占用了大量的CPU时间，执行命令仍然是单线程，看过初略对比，多线程读写性能是单线程的两倍

redis事务
客户端执行multi命令，客户端状态切换，从非事务状态切换到事务状态，不支持嵌套事务
redis事务不支持回滚
Redis事务执行过程中，如果一个命令执行出错，那么就返回错误，然后还是会接着继续执行下面的命令。

命令入队
如果客户端发送的命令为 EXEC、DISCARD、WATCH、MULTI 四个命令的其中一个，那么服务器立即执行这个命令。
与此相反，如果客户端发送的命令是 EXEC、DISCARD、WATCH、MULTI 四个命令以外的其他命令，那么服务器并不立即执行这个命令。
首先检查此命令的格式是否正确，如果不正确，服务器会在客户端状态（redisClient）的 flags 属性打开 REDIS_MULTI 标识，并且返回错误信息给客户端。
如果正确将这个命令放入一个事务队列里面，然后向客户端返回 QUEUED 回复。

客户端发送 EXEC 命令，服务器执行 EXEC 命令逻辑。

如果客户端状态的 flags 属性不包含 REDIS_MULTI 标识，或者包含 REDIS_DIRTY_CAS 或者 REDIS_DIRTY_EXEC 标识，那么就直接取消事务的执行。
否则客户端处于事务状态（flags 有 REDIS_MULTI 标识），服务器会遍历客户端的事务队列，然后执行事务队列中的所有命令，最后将返回结果全部返回给客户端；

redis作缓存

什么是缓存雪崩？
缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。
例如，
1，Redis挂掉了，请求全部走数据库。
2，对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。

如何预防缓存雪崩？
1，缓存数据设置的过期时间是相同
解决在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。
2，Redis挂掉
事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。
事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

什么是缓存穿透？
查询一个一定不存在的数据。由于缓存不命中，并且出于容错考虑，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。
请求的数据在缓存大量不命中，导致请求走数据库。

如何预防缓存穿透？
1，接口参数校验，由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter提前拦截，不合法就不让这个请求到数据库层！
2，当我们从数据库找不到的时候，我们也将这个空对象设置到缓存里边去。下次再请求的时候，就可以从缓存里边获取了。这种情况我们一般会将空对象设置一个较短的过期时间。
从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值具体取啥问产品，或者看具体的场景，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。

Redis还有一个高级用法**布隆过滤器（Bloom Filter）**这个也能很好的防止缓存穿透的发生，
他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。

什么是缓存击穿？
至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，
而缓存击穿不同的是缓存击穿是指一个Key非常热点，在不停的扛着大并发，
大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

如何保证缓存和数据库的一致性？
四种缓存模式：
cache aside模式 cache和数据库分开
读操作，缓存没有时，读数据库然后写进缓存；写操作，先写数据库，然后使缓存失效
什么时候使用：
1，当Cache不提供原生的Read-Through和Write-Through操作的时候
2，资源的需求是不可预测的时候。Cache-Aside模式令应用可以根据需求来加载数据。对于应用需求什么数据，不需要提前做出假设。

read through模式 缓存和数据库是一个整体
write through模式 缓存和数据库是一个整体
write back模式 读写都在缓存，异步批量更新数据库

什么是分布式锁？
分布式锁是不同进程间采用互斥的方式操作共享资源。

为什么需要分布式锁？
Volatile、Synchronized、ReentrantLock等保证进程内的线程安全，但无法同时锁住两台不同机器上的代码，所以需要分布式锁。

解决了什么问题？
1，提升效率：加锁是为了避免不必要的重复处理。例如防止幂等任务被多个执行者抢占。此时对锁的正确性要求不高；
2，保证正确性：加锁是为了避免Race Condition导致逻辑错误。例如直接使用分布式锁实现防重，幂等机制。此时如果锁出现错误会引起严重后果，因此对锁的正确性要求高。

分布式锁有哪些场景？
分布式服务基于原数据进行更新操作的时候都有类似需求

分布式锁有哪些方案？
1，Reids的分布式锁，很多大公司会基于Redis做扩展开发。  redis分布式锁
2，基于Zookeeper  zookeeper分布式锁
3，基于数据库，比如Mysql。

redis分布式锁实现方案

加锁：set函数可以实现对key设置值，为防止死锁，并设置过期时间，根据返回的true或false判断是否已经加锁
public class RedisLockDemo {    
private static final String SET_IF_NOT_EXIST = "NX";    
private static final String SET_WITH_EXPIRE_TIME = "PX";    
/**     * 获取分布式锁     
* @param jedis Redis客户端     
* @param lockKey 锁     
* @param requestId 请求标识     
* @param expireTime 超期时间     
* @return 是否获取成功     
*/    
public static boolean getLock(Jedis jedis, String lockKey, String requestId, int expireTime) {    
// 两步合二为一，一行代码加锁并设置 + 过期时间。        
if (1 == jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime)) {
            return true;//加锁成功        
}        
    return false;//加锁失败    
}}

解锁：利用lua脚本实现解锁的原子性，根据返回的true或false判断是否已经解锁
public class RedisTool {    
private static final Long RELEASE_SUCCESS = 1L;    
/**     
* 释放分布式锁     
* @param jedis Redis客户端     
* @param lockKey 锁     
* @param requestId 请求标识     
* @return 是否释放成功     
*/    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {        
String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";        
Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));        
if (RELEASE_SUCCESS.equals(result)) {            
return true;        
}        
return false;    
}}

当使用redis作分布式锁的时候，也需要考虑redis的部署问题
redis有3种部署方式：
1，单机模式
2，master-slave + sentinel选举模式
3，redis cluster模式
使用redis做分布式锁的缺点在于：如果采用单机部署模式，会存在单点问题，只要redis故障了。加锁就不行了。
采用master-slave模式，加锁的时候只对一个节点加锁，即便通过sentinel做了高可用，但是如果master节点故障了，发生主从切换，此时就会有可能出现锁丢失的问题。
如果采用redis cluster模式，同样会有上述问题，加锁会先对集群中的某个主节点加锁，然后异步复制到其备节点。如果还没复制到备节点时，主节点宕机，这时备节点上选举为主节点。这把锁已经丢失。
所以这种方式有以下俩个缺点：
1，会有锁丢失的问题
2，set key value nx px 3000 如果3000毫秒之后业务逻辑还没执行完，key过期，锁释放。其他线程获取到锁。这样一来也会造成线程安全问题。

目前已经有成熟的Redis分布式锁开源框架
Redisson
操作封装了很多细节，提供了两个接口，只需要通过它的api中的lock和unlock即可完成分布式锁
1，redisson所有指令都通过lua脚本执行，redis支持lua脚本原子性执行
2，redisson设置一个key的默认过期时间为30s,如果某个客户端持有一个锁超过了30s怎么办？
3，redisson中有一个watchdog的概念，翻译过来就是看门狗，它会在你获取锁之后，每隔10秒帮你把key的超时时间重新延后30s，这样的话，就不会出现业务没执行完而key过期了，其他线程获取到锁的问题了。
4，redisson的“看门狗”逻辑保证了没有死锁发生。(如果机器宕机了，看门狗也就没了。此时就不会延长key的过期时间，到了30s之后就会自动过期了，其他线程可以获取到锁)

zookeeper分布式锁实现方案

使用zk的临时顺序节点的特性来实现
1，客户端调用create()方法创建名为“/dlm-locks/lockname/lock-”的临时顺序节点。
2，客户端调用getChildren(“lockname”)方法来获取所有已经创建的子节点。
3，客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，就是看自己创建的序列号是否排第一，
如果是第一，那么就认为这个客户端获得了锁，在它前面没有别的客户端拿到锁。如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。
直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。

目前有成熟的开源zk客户端curator，也可以实现分布式锁
也封装了很多逻辑，对外提供了两个接口
InterProcessMutex interProcessMutex =  new InterProcessMutex(client,"/anyLock");`
interProcessMutex.acquire();`
interProcessMutex.release();`



zk和redis分布式锁的对比
先说Reids：
Rdis只保证最终一致性，副本间的数据复制是异步进行（Set是写，Get是读，Reids集群一般是读写分离架构，存在主从同步延迟情况），
主从切换之后可能有部分数据没有复制过去可能会丢失锁情况，故强一致性要求的业务不推荐使用Reids，推荐使用zk。
Redis集群各方法的响应时间均为最低。随着并发量和业务数量的提升其响应时间会有明显上升（公有集群影响因素偏大），但是极限qps可以达到最大且基本无异常
再说ZK：
使用ZooKeeper集群，锁原理是使用ZooKeeper的临时节点，临时节点的生命周期在Client与集群的Session结束时结束。
因此如果某个Client节点存在网络问题，与ZooKeeper集群断开连接，Session超时同样会导致锁被错误的释放（导致被其他线程错误地持有），因此ZooKeeper也无法保证完全一致。
ZK具有较好的稳定性；响应时间抖动很小，没有出现异常。但是随着并发量和业务数量的提升其响应时间和qps会明显下降。


对于redis的分布式锁而言，它有以下缺点：
1，它获取锁的方式简单粗暴，获取不到锁直接不断尝试获取锁，比较消耗性能。
2，另外来说的话，redis的设计定位决定了它的数据并不是强一致性的，在某些极端情况下，可能会出现问题。锁的模型不够健壮
即便使用redlock算法来实现，在某些复杂场景下，也无法保证其实现100%没有问题，关于redlock的讨论可以看How to do distributed locking

但是另一方面使用redis实现分布式锁在很多企业中非常常见，而且大部分情况下都不会遇到所谓的“极端复杂场景”
所以使用redis作为分布式锁也不失为一种好的方案，最重要的一点是redis的性能很高，可以支撑高并发的获取、释放锁操作。

对于zk分布式锁而言:
1，zookeeper天生设计定位就是分布式协调，强一致性。锁的模型健壮、简单易用、适合做分布式锁。
如果获取不到锁，只需要添加一个监听器就可以了，不用一直轮询，性能消耗较小。
但是zk也有其缺点：如果有较多的客户端频繁的申请加锁、释放锁，对于zk集群的压力会比较大。


使用分布式锁，必须满足两个条件之一：

1，业务本身不要求强一致性，可以接受偶尔出现锁被其他线程重复获取。
2，业务本身要求强一致性，如果锁被错误地重复获取，必须有降级方案保证一致性。
无论ZooKeeper与Redis，在极端情况下（例如整个ZK集群失效，例如Reids的Master失效而Slave没完全同步）都会存在正在被加锁的资源被重复加锁的问题。这种不可靠的概率极低，主要依赖于Zk集群与Redis集群。

