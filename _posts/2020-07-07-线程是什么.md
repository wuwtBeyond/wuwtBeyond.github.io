<font size="3">
&emsp;&emsp;多线程并发线程需要靠多个线程不停地压榨CPU来提高处理能力，所以了解和熟悉线程是多线程并发编程的重要基础知识。<br>
</font>

#### 线程基础
<font size="3">
&emsp;&emsp;进程是系统进行资源分配和调度的基本单位，一个进程中至少有一个线程，进程中的多个线程共享进程的资源，线程是CPU分配的基本单位。<br>

&emsp;&emsp;在Java中，启动main函数其实就是启动了一个JVM进程，main函数所在的线程就是进程中的一个线程，也就是主线程。<br>

&emsp;&emsp;线程是CPU执行的基本单位，而CPU一般是使用时间片轮转方式让线程轮询占用的，当前线程CPU时间片用完后，要让出CPU，等到下次轮到自己的时候再执行。
如何知道之前程序执行到哪？程序计数器是为了记录该线程让出CPU的执行地址，待再次分配到时间片时，线程可以从自己私有的计数器指定地址继续运行。
如果执行的是native方法，程序计数器记录的是undefined地址；执行的是Java代码时，记录的是下一条指令的地址。<br>

&emsp;&emsp;线程调用start方法后并没有马上执行，而是出于就绪状态，就绪状态是指线程已经获取了除CPU资源外的其它资源，等待获取CPU资源后才会真正处于运行状态。
</font>

#### 线程上下文切换
<font size="3">
&emsp;&emsp;线程进行上下文切换时，需要保存当前线程的执行现场，再次执行时根据保存的现场恢复执行现场。<br>
&emsp;&emsp;线程上下文切换时机有：<br>
&emsp;&emsp;1. 当前线程CPU时间使用完<br>
&emsp;&emsp;2. 当前线程阻塞挂起或被其它线程中断<br>
</font>

#### 守护线程和用户线程
<font size="3">
&emsp;&emsp;Java中的线程分为两类，分别为daemon线程（守护线程）和user线程（用户线程）。JVM启动时会调用main函数，main函数所在的线程就是一个用户线程，不过JVM启动的时候还会启动很多守护线程，比如垃圾回收线程。<br>
&emsp;&emsp;用户线程和守护线程的区别在于，当最后一个非守护线程结束时，JVM会正常退出，而不管当前是否有守护线程，就是说有一个用户线程还没结束，正常情况下JVM就不会退出。<br>

<font size="3">
<p>thread.setDaemon(true)</p>
</font>

&emsp;&emsp;main线程运行结束后，JVM会自动启动一个叫做DestroyJavaVM的线程，该线程会等待所有用户线程结束后终止JVM进程。<br>

&emsp;&emsp;在Tomcat的NIO实现中，NioEndpoint中会开启一组接受线程来接受用户的连接请求，以及一组处理线程负责具体处理用户请求。在默认情况下，接受线程和处理线程都是守护线程，这意味着当tomcat收到shutdown命令后且
没有其它用户线程存在的情况下，tomcat进程会马上消亡，不会等待处理线程处理完当前的请求。
</font>

##### 参考
<font size="3">
《并发编程之美》
</font>