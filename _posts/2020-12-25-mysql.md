mysql三种日志总结  binlog redo undo 看懂就能明白 https://my.oschina.net/javazhiyin/blog/4517915

mysql事务的流程 https://www.imooc.com/article/247122

InnoDB引擎支持事务，进而有了undo/redo日志，binlog日志是mysql server的日志
https://blog.csdn.net/qq_42651904/article/details/104549645
一条SQL语句更新的流程？
1、加载磁盘文件到 Buffer Pool 缓冲池中
2、将未修改的数据写入undo日志中，作用：便于数据回滚
3、更新缓存Buffer Pool 的数据
4、写入redo日志，redo日志则是记录了对哪个数据做了修改
5、准备提交事务将redo日志写入磁盘
6、准备提交事务将binlog日志写入磁盘（binlog日志记录对哪个数据做了修改，修改结果是什么）
7、将binlog更新的文件名和更新文件的位置写入redo，并在redo log添加commit标记
8、IO线程随机将 Buffer Pool 缓冲池中的数据刷入磁盘
https://blog.csdn.net/qq_39088066/article/details/102651838
1、undo日志
当更新一条数据的时候，将未修改的数据写入undo日志中 作用：便于数据回滚
2、redo日志
redo日志记录了修改后的值，防止数据丢失
假如我们修改了Buffer Pool缓存中的值，还没有来得及刷新磁盘中的数据，数据库宕机了，那么Buffer Pool缓存中的数据丢失不是让磁盘中这一条数据成了脏数据吗？
因为有redo日志，可以通过redo日志恢复所以是不要紧的。
redo可以设置以下几种刷盘策略，他是通过参数innodb_flush_log_at_trx_commit配置的
当参数为0时，提交事务不会将redo日志强制刷入磁盘
当参数为1时，提交事务成功一定会将redo日志写入磁盘
当参数为2时，提交事务时将redo日志写入os cache缓存中，1秒后写入磁盘
3、binlog日志
binlog日志也有参数控制刷盘策略，sync_binlog，默认为0表示不是直接写入磁盘，也是先写入os cache缓存中，所以这里建议是吧sync_binlog参数设置为1，强制在提交事务的时候写入磁盘
应用场景：故障恢复
应用场景：主从同步
4、为什么最后redo日志要写入commit标记？
为了保证binlog日志和redo日志的一致性
假设redo日志刚刚写入磁盘文件后mysql宕机了，不会因为redo日志有数据而binlog没有数据产生数据不一致问题，因为redo日志文件没有最终标记commit，所以这次事务是提交失败的
5、redo log和bin log的区别？
redo log是物理日志，记录了在数据页上做了什么修改；bin log是逻辑日志，记录了sql的原始逻辑
redo log是InnoDB引擎特有的，bin log是mysql server层实现的，所有引擎都会有
redo log是循环写的，有固定空间，bin log是追加写入的,日志文件会切分固定块大小
6、可不可以只要bin log，不要redo log?
不可以
redo log 是循环写不能保证所有的历史数据，这些历史数据只能在 binlog 中找到；
binlog 是高可用的基础，高可用的实现原理就是 binlog 复制。
7、事务执行期间，还未提交，如果发生crash，redo log丢失，是否会导致主备不一致？
不会
这时候 binlog 也还在 binlog cache 里，没发给备库，crash 以后 redo log 和 binlog 都没有了，从业务角度看这个事务也没有提交，所以数据是一致的。

mysql慢查询
1，cpu负载高  一般查询语句带有计算逻辑，检查
2，io负载高  一般是查询了没建索引的列

可以设置查询时长，过滤查询时长特别长的SQL

有些SQL虽然出现在慢查询日志中，但未必是其本身的性能问题，可能是因为锁等待，服务器压力高等等。
需要分析SQL语句真实的执行计划，而不是看重新执行一遍SQL时，花费了多少时间
由自带的慢查询日志或者开源的慢查询系统定位到具体的出问题的SQL，然后使用Explain工具来逐步调优
了解 MySQL 在执行这条数据时的一些细节，比如是否进行了优化、是否使用了索引等等。
基于 Explain 的返回结果我们就可以根据 MySQL 的执行细节进一步分析是否应该优化搜索、怎样优化索引。

关于sql调优，个人特别推荐美团点评技术团队的几点总结

最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整；
尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录；
索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。


基于本文的思路，关于SQL慢查询的解决可以按照以下的步骤执行：
1. 打开慢日志查询，确定是否有SQL语句占用了过多资源，如果是，在不改变业务原意的前提下，对insert、group by、order by、join等语句进行优化。
2. 考虑调整MySQL的系统参数： innodb_buffer_pool_size、innodb_log_file_size、table_cache等。
3. 确定是否是因为高并发引起行锁的超时问题。
4. 如果数据量过大，需要考虑进一步的分库分表

生产环境碰到的实际问题：
线上数据库建立索引导致锁表

https://juejin.cn/post/6844903988375224328
MySQL引擎：
InnoDB 引擎(MySQL5.5以后默认使用)
1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。
3）InnoDB支持外键，MyISAM不支持
5）InnoDB不支持FULLTEXT类型的索引
6）InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表。
7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。
8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。
9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'

https://juejin.cn/post/6844904126585765902
索引（在MySQL中也叫做键<key>），是存储引擎用于快速找到记录的一种数据结构。
索引本身很大，不可能全部存储在内存中，因此索引以索引表的形式存储在磁盘中。
构建优化索引原则：
1，索引可以包含一个或多个列的值，最左前缀匹配原则
(1) 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。
(2) 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。
(3) 尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。

MySQL索引底层实现
索引也是需要存储在磁盘中的，而不能全部都放在内存中，所以我们在考虑选用哪种数据结构时，我们可以换一个角度思考，
哪个数据结构更适合从磁盘中读取数据，或者哪个数据结构能够提高磁盘的IO效率。

Mysql中的索引是用B+树实现
为什么哈希表、完全平衡二叉树、B树、B+树都可以优化查询，为何Mysql独独喜欢B+树？
哈希表：不支持范围查询
完全平衡二叉树：相比于B树，不够矮 
B树：B树中的一个节点可以存储多个元素。
B+树：B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连。

B+树的优势：
B树的优点：一个节点可以存储多个元素，相对于完全平衡二叉树所以整棵树的高度就降低了，磁盘IO效率提高了。
而，B+树是B树的升级版，只是把非叶子节点冗余一下，这么做的好处是为了提高范围查找的效率。

B+树中一个节点到底存多少个元素合适？
B+树中一个节点为一页或页的倍数最为合适。因为如果一个节点的大小小于1页，那么读取这个节点的时候其实也会读出1页，造成资源的浪费；
如果一个节点的大小大于1页，比如1.2页，那么读取这个节点的时候会读出2页，也会造成资源的浪费；
所以为了不造成浪费，所以最后把一个节点的大小控制在1页、2页、3页、4页等倍数页大小最为合适。

B+树中的一个节点存储的内容是：
非叶子节点：主键+指针
叶子节点：数据

Innodb中的主键索引和实际数据时绑定在一起的，也就是说Innodb的一个表一定要有主键索引
https://juejin.cn/post/6844903792861790222
什么是聚集索引?
LnnoDB的主键索引就是一个聚集索引(索引和主键对应的数据放在同一个B+树)

mysql事务  https://www.cnblogs.com/exceptioneye/p/5451960.html
MySQL 本身不提供事务支持，而是开放了存储引擎接口，由具体的存储引擎来实现，具体来说支持 MySQL 事务的存储引擎就是 InnoDB。

存储引擎实现事务的通用方式是基于 redo log 和 undo log。

简单来说，redo log 记录事务修改后的数据, undo log 记录事务前的原始数据。

所以当一个事务执行时实际发生过程简化描述如下：

先记录 undo/redo log，确保日志刷到磁盘上持久存储。
更新数据记录，缓存操作并异步刷盘。
提交事务，在 redo log 中写入 commit 记录。
在 MySQL 执行事务过程中如果因故障中断，可以通过 redo log 来重做事务或通过 undo log 来回滚，确保了数据的一致性。

这些都是由事务性存储引擎来完成的，但 binlog 不在事务存储引擎范围内，而是由 MySQL Server 来记录的。

那么就必须保证 binlog 数据和 redo log 之间的一致性，所以开启了 binlog 后实际的事务执行就多了一步，如下：

先记录 undo/redo log，确保日志刷到磁盘上持久存储。
更新数据记录，缓存操作并异步刷盘。
将事务日志持久化到 binlog。
提交事务，在 redo log 中写入commit记录。
这样的话，只要 binlog 没写成功，整个事务是需要回滚的，而 binlog 写成功后即使 MySQL Crash 了都可以恢复事务并完成提交。

要做到这点，就需要把 binlog 和事务关联起来，而只有保证了 binlog 和事务数据的一致性，才能保证主从数据的一致性。

所以 binlog 的写入过程不得不嵌入到纯粹的事务存储引擎执行过程中，并以内部分布式事务（xa 事务）的方式完成两阶段提交。

mysql事务隔离级别  
ACID
隔离级别从弱到强 https://developer.ibm.com/zh/technologies/databases/articles/os-mysql-transaction-isolation-levels-and-locks/
读未提交 
该隔离级别的事务会读到其它未提交事务的数据，此现象也称之为 脏读 。
读已提交
一个事务可以读取另一个已提交的事务，多次读取会造成不一样的结果，此现象称为不可重复读问题，Oracle 和 SQL Server 的默认隔离级别。
可重复读
MySQL 默认的隔离级别 在同一个事务里， select 的结果是事务开始时时间点的状态，因此，同样的 select 操作读到的结果会是一致的，但是，会有 幻读 现象。
串行化
在该隔离级别下事务都是串行顺序执行的，MySQL 数据库的 InnoDB 引擎会给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。

mysql中的锁
InnoDB 实现了两种类型的行级锁：
共享锁 （也称为 S 锁）：允许事务读取一行数据。
可以使用 SQL 语句 select * from tableName where... lock in share mode; 手动加 S 锁。
独占锁 （也称为 X 锁）：允许事务删除或更新一行数据。
可以使用 SQL 语句 select * from tableName where... for update; 手动加 X 锁。
S 锁和 S 锁是 兼容 的，X 锁和其它锁都 不兼容

为了实现多粒度的锁机制，InnoDB 还有两种内部使用的 意向锁 ，由 InnoDB 自动添加，且都是表级别的锁。
意向共享锁 （IS）：事务即将给表中的各个行设置共享锁，事务给数据行加 S 锁前必须获得该表的 IS 锁。
意向排他锁 （IX）：事务即将给表中的各个行设置排他锁，事务给数据行加 X 锁前必须获得该表 IX 锁。
意向锁的主要目的是为了使得 行锁 和 表锁 共存。

innoDB 行锁的实现算法

mysql出现死锁怎么办？
InnoDB 引擎采取的是 wait-for graph 等待图的方法来自动检测死锁，如果发现死锁会自动回滚一个事务。

mysql中锁的优化方法？
1，合理设计索引，让 InnoDB 在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他 Query 的执行。
2，尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录。
3，尽量控制事务的大小，减少锁定的资源量和锁定时间长度。
4，在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少 MySQL 因为实现事务隔离级别所带来的附加成本。