### 背景
<font size="3">
&emsp;&emsp;一直不太清楚在JDK中包含的那些原生有关并发的基础方法的作用，由于平时没有实际用到过，所以着重研究了下这些方法的异同点。<br>
</font>

#### 线程基础
<font size="3">
&emsp;&emsp;进程是系统进行资源分配和调度的基本单位，一个进程中至少有一个线程，进程中的多个线程共享进程的资源，线程是CPU分配的基本单位。<br>

&emsp;&emsp;在Java中，启动main函数其实就是启动了一个JVM进程，main函数所在的线程就是进程中的一个线程，也就是主线程。<br>

&emsp;&emsp;线程是CPU执行的基本单位，而CPU一般是使用时间片轮转方式让线程轮询占用的，当前线程CPU时间片用完后，要让出CPU，等到下次轮到自己的时候再执行。
如何知道之前程序执行到哪？程序计数器是为了记录该线程让出CPU的执行地址，待再次分配到时间片时，线程可以从自己私有的计数器指定地址继续运行。
如果执行的是native方法，程序计数器记录的是undefined地址；执行的是Java代码时，记录的是下一条指令的地址。<br>

&emsp;&emsp;线程调用start方法后并没有马上执行，而是出于就绪状态，就绪状态是指线程已经获取了除CPU资源外的其它资源，等待获取CPU资源后才会真正处于运行状态。
</font>
#### 线程通知与等待
##### wait方法
<font size="3">
&emsp;&emsp;当一个线程调用了某对象的wait方法时，该线程会被阻塞挂起，直到发生下面几件事情之一才返回：<br>
1. 其它线程调用了该共享对象的notify或者notifyAll方法。<br>
2. 其它线程调用了该线程的interrupt方法，该线程抛出InterruptedException异常返回。<br>

&emsp;&emsp;如果线程调用wait方法时，没有事先获取该对象的监视器锁，则线程调用wait方法时会抛出IllegalMonitorStateException。

&emsp;&emsp;当前线程调用共享变量的wait的方法后，只会释放当前共享变量的锁，如果当前线程还持有其它共享变量的锁，则这些锁是不会被释放。<br>

PS：wait(long timeout)方法<br>

&emsp;&emsp;相比于wait函数，多了一个超时参数，不同之处在于，如果一个线程调用共享对象的wait方法挂起后，没有在指定的timeout内被其它的线程调用该共享变量的notify或notifyAll方法唤醒，该函数会因为超时而返回。
</font>
##### notify方法
<font size="3">
&emsp;&emsp;一个线程调用共享对象的notify方法后，会唤醒一个在该共享变量调用wait方法被挂起的线程，一个共享变量上可能会有多个线程被挂起等待，具体唤醒哪个线程是随机的。
被唤醒的线程不能马上从wait方法返回并继续执行，它必须获取到锁后才能继续执行，就是说被唤醒的线程不一定会获取到该共享对象的监视器锁，因为该线程需要和其它线程一起竞争该锁，只有该线程竞争到该变量的锁后，才能继续执行。<br>

&emsp;&emsp;只有当前线程获取到共享对象的锁后，才可以调用notify方法，否则会抛出IllegalMonitorStateException。<br>

PS：notifyAll方法<br>

&emsp;&emsp;不同于notify函方法随机唤醒阻塞在该共享变量的一个线程，notifyAll方法会唤醒所有在该共享变量由于调用wait方法而被挂起的线程。
</font>
##### join方法
<font size="3">
&emsp;&emsp;join方法是Thread类直接提供的，join是无参且返回值为void的方法。线程A调用线程B的join方法后会阻塞，当其它线程调用了线程A的interrupt方法中断线程A时，线程A抛出InterruptException异常而返回。
</font>

##### sleep方法
<font size="3">
&emsp;&emsp;sleep方法是Thread类中的静态方法，当一个执行中的线程调用了Thread类的sleep方法后，调用线程会暂时放弃CPU，但不会放弃线程持有的监视器资源，比如锁。
指定的时间到后，函数会正常返回，此时线程处于就绪状态，参与CPU的调度，获取到CPU资源后就可以继续运行。如果在睡眠期间其它线程调用了该线程的interrupt方法中断了该线程，则该线程会在调用sleep的地方抛出InterruptedException异常而返回。
</font>

##### yield方法（很少使用）
<font size="3">
&emsp;&emsp;Thread类中有一个静态的yield方法，当一个线程调用yield方法时，实际上是暗示当前线程放弃自己的CPU，但是线程调度器可以无条件忽略这个请求。仍有可能调度到当前线程执行。<br>
&emsp;&emsp;sleep和yield方法的区别在于，当线程调用sleep方法时，调用线程会被阻塞挂起指定的时间，在这期间线程调度器不会去调度该线程，而调用yield方法，线程只是让出自己剩余的时间片，并没有阻塞挂起，而是处于就绪状态，线程调度器下次调度时
</font>

##### interrupt方法
<font size="3">
&emsp;&emsp;线程中断是线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程自行处理。<br>
&emsp;&emsp;interrupt方法，中断线程，线程A运行时，线程B可以调用线程A的interrupt方法设置A的中断标志为true并立即返回。如果线程A调用了wait、join、sleep方法而被阻塞挂起，这时线程B调用线程A的interrupt方法，线程A会在调用这些方法的地方抛出InterruptedException异常返回。<br>
&emsp;&emsp;isInterrupted方法，检测当前线程是否中断<br>
&emsp;&emsp;interrupted方法，检测当前线程是否中断，与isInterrupted不同的是，如果发现当前线程被中断，会清除中断标志，并且该方法是静态方法，可以通过Thread类直接调用。
<font size="3">

## 参考
《并发编程之美》
