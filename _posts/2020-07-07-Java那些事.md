
### 线程基础
<font size="3">
&emsp;&emsp;进程是系统进行资源分配和调度的基本单位，一个进程中至少有一个线程，进程中的多个线程共享进程的资源，线程是CPU分配的基本单位。<br>

&emsp;&emsp;在Java中，启动main函数其实就是启动了一个JVM进程，main函数所在的线程就是进程中的一个线程，也就是主线程。<br>

&emsp;&emsp;线程是CPU执行的基本单位，而CPU一般是使用时间片轮转方式让线程轮询占用的，当前线程CPU时间片用完后，要让出CPU，等到下次轮到自己的时候再执行。
如何知道之前程序执行到哪？程序计数器是为了记录该线程让出CPU的执行地址，待再次分配到时间片时，线程可以从自己私有的计数器指定地址继续运行。
如果执行的是native方法，程序计数器记录的是undefined地址；执行的是Java代码时，记录的是下一条指令的地址。<br>

&emsp;&emsp;线程调用start方法后并没有马上执行，而是出于就绪状态，就绪状态是指线程已经获取了除CPU资源外的其它资源，等待获取CPU资源后才会真正处于运行状态。<br>
</font>
### 线程通知与等待
#### wait方法
<font size="3">
&emsp;&emsp;当一个线程调用了某对象的wait方法时，该线程会被阻塞挂起，直到发生下面几件事情之一才返回：<br>
1. 其它线程调用了该共享对象的notify或者notifyAll方法。<br>
2. 其它线程调用了该线程的interrupt方法，该线程抛出InterruptedException异常返回。<br>

&emsp;&emsp;如果线程调用wait方法时，没有事先获取该对象的监视器锁，则线程调用wait方法时会抛出IllegalMonitorStateException。
&emsp;&emsp;当前线程调用共享变量的wait的方法后，只会释放当前共享变量的锁，如果当前线程还持有其它共享变量的锁，则这些锁是不会被释放。<br>

PS：wait(long timeout)函数<br>
&emsp;&emsp;相比于wait函数，多了一个超时参数，不同之处在于，如果一个线程调用共享对象的wait方法挂起后，没有在指定的timeout内被其它的线程调用该共享变量的notify或notifyAll方法唤醒，该函数会因为超时而返回。<br>
</font>
#### notify方法
<font size="3">
&emsp;&emsp;一个线程调用共享对象的notify方法后，会唤醒一个在该共享变量调用wait方法被挂起的线程，一个共享变量上可能会有多个线程被挂起等待，具体唤醒哪个线程是随机的。
被唤醒的线程不能马上从wait方法返回并继续执行，它必须获取到锁后才能继续执行，就是说被唤醒的线程不一定会获取到该共享对象的监视器锁，因为该线程需要和其它线程一起竞争该锁，只有该线程竞争到该变量的锁后，才能继续执行。<br>

&emsp;&emsp;只有当前线程获取到共享对象的锁后，才可以调用notify方法，否则会抛出IllegalMonitorStateException。

PS：notifyAll函数<br>
&emsp;&emsp;不同于notify函方法随机唤醒阻塞在该共享变量的一个线程，notifyAll方法会唤醒所有在该共享变量由于调用wait方法而被挂起的线程。<br>
</font>
#### join方法

## 参考

