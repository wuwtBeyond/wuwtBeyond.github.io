<font size="3">
&emsp;&emsp;很多开发同学可能只是大概了解这些用法，但如果深入研究下，会有很大的收获，也能更好地使用他们。<br>
</font>

##### 并发编程的潜在问题
<font size="3">
&emsp;&emsp;当一个线程调用了某对象的wait方法时，该线程会被阻塞挂起，直到发生下面几件事情之一才返回：<br>
&emsp;&emsp;1. 其它线程调用了该共享对象的notify或者notifyAll方法。<br>
&emsp;&emsp;2. 其它线程调用了该线程的interrupt方法，该线程抛出InterruptedException异常返回。<br>

&emsp;&emsp;如果线程调用wait方法时，没有事先获取该对象的监视器锁，则线程调用wait方法时会抛出IllegalMonitorStateException。<br>

&emsp;&emsp;当前线程调用共享变量的wait的方法后，只会释放当前共享变量的锁，如果当前线程还持有其它共享变量的锁，则这些锁是不会被释放。<br>

PS：wait(long timeout)方法<br>

&emsp;&emsp;相比于wait函数，多了一个超时参数，不同之处在于，如果一个线程调用共享对象的wait方法挂起后，没有在指定的timeout内被其它的线程调用该共享变量的notify或notifyAll方法唤醒，该函数会因为超时而返回。
</font>

##### 参考
<font size="3">
《并发编程之美》
</font>